<?xml version="1.0"?>
<doc>
<assembly>
<name>
PFP
</name>
</assembly>
<members>
<member name="T:PFP.My.Resources.Resources">
<summary>
  Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.ResourceManager">
<summary>
  Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.Culture">
<summary>
  Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
  Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.buyorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.createorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.logo">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Icon ähnlich wie (Symbol).
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.OpenOrder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.responseopenorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.settings">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.showmyopenorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.symbol">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="M:PFP.PFPForm.GetLVColNameFromSubItem(System.Windows.Forms.ListView@,System.String,System.Windows.Forms.ListViewItem,System.Int32)">
 <summary>
 Von einer ListView das subitem aus dem item lesen
 </summary>
 <param name="LV">Die ListView, aus der gelesen werden soll</param>
 <param name="ColName">Der Spaltenname, aus dem gelesen werden soll</param>
 <param name="LVItem">Die Zeile bzw. das item aus dem gelesen werden soll</param>
 <param name="index">Alternativ das item an index stelle in der ListView</param>
 <returns>Vorzugsweise einen String, andernfalls den index der Spalte</returns>
 <remarks></remarks>
</member>
<member name="M:PFP.PFPForm.GetThread">
 <summary>
 The Thread who coordinates (loadbalance) the API Request subthreads
 </summary>
</member>
<member name="M:PFP.PFPForm.SubGetThread(System.Object)">
 <summary>
 The SubThread who process the request
 </summary>
 <param name="Input">The input to work with Input(0) = List-Index; Input(1) = APIRequest</param>
</member>
<member name="T:PFP.ListViewItemExtremeSorter">
 <summary>
 Beispiel Standard:
 ListView1.ListViewItemSorter = New ListViewItemExtremeSorter(SortOrder.Ascending, 0, 0, 1, 0, 3, 1)
 </summary>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.#ctor(System.Windows.Forms.SortOrder,System.Collections.Generic.List{System.Object})">
 <summary>
 Sortiert die angegebene(n) Spalte(n) der ListView
 </summary>
 <param name="Sortfolge">Die SortierRehenfolge (Aufsteigend oder Absteigend)</param>
 <param name="SortList">Liste mit Indexschlüssel als Integer und Alphanumerische Angaben als Integer (z.b. New List(Of Object) ({New Object() {0, 0}, New Object() {7, 0}, New Object() {8, 1}}))</param>
 <remarks></remarks>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.#ctor(System.Windows.Forms.SortOrder,System.Windows.Forms.ListView@,System.Collections.Generic.List{System.Object})">
 <summary>
 Sortiert die angegebene(n) Spalte(n) der ListView
 </summary>
 <param name="Sortfolge">Die SortierRehenfolge (Aufsteigend oder Absteigend)</param>
 <param name="LV">Die ListView, aus der die ColumnIDX bezogen werden können</param>
 <param name="SortList">Liste mit Indexschlüssel als Integer und Alphanumerische Angaben als Integer (z.b. New List(Of Object)({New Object() {"Datum", 0}, New Object() {"Mitarbeiter", 0}, New Object() {"Reihenfolge", 1}}))</param>
 <remarks></remarks>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.#ctor(System.Windows.Forms.SortOrder,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Sortiert die angegebene(n) Spalte(n) der ListView
 </summary>
 <param name="Sortfolge">Die SortierRehenfolge (Aufsteigend oder Absteigend)</param>
 <param name="Pri">Primärschlüssel: Index der 1. Spalte (muss vorhanden sein)</param>
 <param name="AlphaNrPri">Optionaler Parameter für Alphanummerische sortierung für Pri</param>
 <param name="Sek">Optionaler Sekundärschlüssel: Index der 2. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrSek">Optionaler Parameter für Alphanummerische sortierung für Sek</param>
 <param name="Ter">Optionaler Tertiärschlüssel: Index der 3. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrTer">Optionaler Parameter für Alphanummerische sortierung für Ter</param>
 <param name="Qua">Optionaler Quartärschlüssel: Index der 4. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrQua">Optionaler Parameter für Alphanummerische sortierung für Qua</param>
 <param name="Qui">Optionaler Quintärschlüssel: Index der 5. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrQui">Optionaler Parameter für Alphanummerische sortierung für Qui</param>
 <remarks></remarks>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.Compare(System.Object,System.Object)">
 <summary>
 Vergleich von Spalten (Primär-/Sekündär-/Tertiärspalte)
 Benennungen von lateinischen Ordnungszahlen: 1=Primär, 2=Sekundär, 3=Tertiär, 4=Quartär, 5=Quintär, 6=Sextär, 7=Septimär, 8=Oktaviär, 9=Noniär, 10=Dezimär, 11=Un(o)dezimär, 12=Duodezimär, 13=Ter(Tres)dezimär
 zur Unterstützung des Sorts im ListView
 </summary>
 <param name="Element1">Element1 als ListViewItem</param>
 <param name="Element2">Element2 als ListViewItem</param>
 <returns>-1, 0 oder 1 (gemäß Vergleich)</returns>
 <remarks></remarks>
</member>
<member name="M:PFP.SignumNET.GenerateMasterKeys">
 <summary>
 Generates the Masterkeys from PassPhrase 0=PublicKey; 1=SignKey; 2=AgreementKey
 </summary>
 <returns>List of Masterkeys</returns>
</member>
<member name="M:PFP.SignumNET.Keygen(System.Byte[])">
 <summary>
 Generates the Masterkeys from KeyHash
 </summary>
 <param name="KeyHash">The 32 Byte hashed PassPhrase</param>
 <returns>Array of Masterkeys</returns>
</member>
<member name="M:PFP.SignumNET.GenerateSignature(System.String,System.String)">
 <summary>
 Generates the Signature of the MessageHEX
 </summary>
 <param name="MessageHEX">Message as HEX String</param>
 <param name="PrivateKey">The Private Key to Sign with</param>
 <returns>Signature in HEX String</returns>
</member>
<member name="M:PFP.SignumNET.VerifySignature(System.String,System.String,System.String)">
 <summary>
 Verify the Signature of the UnsignedMessageHEX String
 </summary>
 <param name="Signature">The Signature as HEX String</param>
 <param name="UnsignedMessageHex">The Unsigned Message as HEX String</param>
 <param name="PublicKey">The Public Key as HEX String</param>
 <returns></returns>
</member>
<member name="M:PFP.SignumNET.EncryptMessage(System.String,System.String,System.String)">
 <summary>
 Encrypts Message from Parameters 0=Data; 1=Nonce
 </summary>
 <param name="Plaintext"></param>
 <param name="RecipientPublicKeyHex"></param>
 <param name="SenderAgreementKeyHex"></param>
 <returns></returns>
</member>
<member name="M:PFP.SignumNET.EncryptData(System.Byte[],System.String,System.String)">
 <summary>
 Encrypt Data from Parameters 0=Data; 1=Nonce
 </summary>
 <param name="Data"></param>
 <param name="RecipientPublicKeyHex"></param>
 <param name="SenderAgreementKeyHex"></param>
 <returns></returns>
</member>
<member name="M:PFP.Curve25519.Clamp(System.Byte[]@)">
 <summary>
 Private key clamping
 </summary>
 <param name="AgreementKey">[in] 32 random bytes, [out] your private key for key agreement</param>
</member>
<member name="M:PFP.Curve25519.KeyGen(System.Byte[]@,System.Byte[]@,System.Byte[]@)">
 <summary>
 Key-Pair generation * WARNING: if s is not NULL, this function has data-dependent timing 
 </summary>
 <param name="PublicKey">[out] your public key</param>
 <param name="SignKey">[out] your private key for signing</param>
 <param name="AgreementKey">[in] 32 random bytes, [out] your private key for key agreement</param>
</member>
<member name="M:PFP.Curve25519.GetSharedSecret(System.Byte[]@,System.Byte[],System.Byte[])">
 <summary>
 Key agreement
 </summary>
 <param name="SharedSecret">[out] shared secret (needs hashing before use)</param>
 <param name="AgreementKey">[in]  your private key for key agreement</param>
 <param name="PublicKey">[in] peer's public key</param>
</member>
<member name="T:PFP.Curve25519.Long10">
 <summary>
 Using this class instead of long[10] to avoid bounds checks. 
 </summary>
</member>
<member name="M:PFP.Curve25519.Copy32(System.Byte[]@,System.Byte[])">
 <summary>
 Copies 32 Bytes from Input to Output
 </summary>
 <param name="Output">[out] Copy of Input</param>
 <param name="Input">[in] Input to Copy to Output</param>
</member>
<member name="M:PFP.EC_KCDSA.Sign(System.Byte[],System.Byte[],System.Byte[])">
 <summary>
 Signature generation primitive, calculates (x-h)s mod q
 </summary>
 <param name="SignHash">signature hash (of message, signature pub key, and context data)</param>
 <param name="SignPrivKey">signature private key</param>
 <param name="PrivKey">private key for signing</param>
 <returns>signature value</returns>
</member>
<member name="M:PFP.EC_KCDSA.Verify(System.Byte[],System.Byte[],System.Byte[])">
 <summary>
 Signature verification primitive, calculates Y = vP + hG
 </summary>
 <param name="SignValue">signature value</param>
 <param name="SignHash">signature hash</param>
 <param name="PublicKey">public key</param>
 <returns>signature public key</returns>
</member>
<member name="M:PFP.GZip.Compress(System.Byte[])">
 <summary>
 Receives bytes, returns compressed bytes.
 </summary>
</member>
<member name="M:PFP.GZip.Inflate(System.Byte[])">
 <summary>
 Receives bytes, returns decompressed bytes.
 </summary>
</member>
<member name="M:PFP.ModFunctions.DateIntToCandle(System.Collections.Generic.List{System.Object})">
 <summary>
 
 </summary>
 <param name="DateValueList">Liste mit Datums und dessen Werte</param>
 <returns></returns>
</member>
<member name="M:PFP.ModFunctions.EMAx(System.Collections.Generic.List{System.Object},System.Int32)">
 <summary>
 
 </summary>
 <param name="DateValueList">Liste mit Datums und dessen Werte</param>
 <param name="EMA">die EMA zahl</param>
 <returns></returns>
</member>
<member name="M:PFP.ModFunctions.MACDx(System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.Object})">
 <summary>
 
 </summary>
 <param name="EMA1">Liste des ersten EMA</param>
 <param name="EMA2">Liste des zweiten EMA</param>
 <returns></returns>
</member>
</members>
</doc>
